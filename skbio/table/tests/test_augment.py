# ----------------------------------------------------------------------------
# Copyright (c) 2013--, scikit-bio development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE.txt, distributed with this software.
# ----------------------------------------------------------------------------

from unittest import TestCase, main

import numpy as np
import numpy.testing as npt

from skbio.tree import TreeNode
from skbio.stats.composition import closure
from skbio.table._augment import (
    mixup,
    aitchison_mixup,
    compositional_cutmix,
    phylomix,
    _validate_labels,
    _all_pairs,
    _intra_class_pairs,
    _aitchison_add,
    _aitchison_scalar_multiply,
)


class AugmentationTests(TestCase):

    def setUp(self):
        # a normal example (10 x 10)
        self.matrix = np.array([
            [ 2,  0,  3,  0,  9, 31,  3,  1,  3,  7],
            [ 9,  0,  8,  4,  1, 24,  0,  0,  3,  6],
            [ 0,  0,  1,  0,  0,  1,  2,  1,  0,  1],
            [ 0,  5,  0,  1,  7,  0,  5,  2,  4,  0],
            [ 0,  0,  5, 22,  1, 10,  4, 16, 19,  0],
            [ 0,  0,  2,  0,  1,  2,  3,  2,  0,  1],
            [ 0,  0,  0,  2,  0,  3,  0,  3,  1,  0],
            [ 5,  2,  0, 14,  0,  3,  3,  5,  9, 51],
            [15,  3,  0,  8, 17,  0,  0,  5,  0,  0],
            [ 0,  3,  5,  0,  2,  2,  2,  0,  4,  1],
        ])
        self.labels_1 = np.zeros(10, dtype=int)  # one class
        self.labels_2 = np.array([0, 0, 0, 1, 0, 1, 1, 1, 0, 0])  # two classes
        self.labels_3 = np.array([1, 1, 0, 2, 0, 0, 0, 2, 1, 2])  # three classes

        self.taxa = [f"O{i}" for i in range(10)]
        self.tree = TreeNode.read([
            "((O6,((O1,O4),O7),((O5,O2),(O3,O8))),(O0,O9));"
        ])

        # a simple example (2 x 5)
        self.data_simple = np.arange(10).reshape(2, 5)
        self.label_simple = np.array([0, 1])
        self.taxa_simple = list("abcde")
        self.tree_simple = TreeNode.read(["(((a,b),c),(d,e));"])

        # # a complex example (40 x 100)
        # self.data = np.arange(4000).reshape(40, 100)
        # rng = np.random.default_rng()
        # self.label = rng.integers(0, 2, size=40)
        # self.one_hot_label = np.eye(2)[self.label]
        # self.taxa = [f"O{i}" for i in range(100)]

        # # This is a random birth-death tree generated by DendroPy. Code:
        # # taxa = dendropy.TaxonNamespace([f"O{i}" for i in range(100)])
        # # tree = dendropy.simulate.treesim.birth_death_tree(
        # #     birth_rate=1.0, death_rate=0.0, num_extant_tips=100,
        # #     taxon_namespace=taxa, rng=random.Random(42))
        # self.tree = TreeNode.read([
        #     "(((((((O59,O57),(O23,O74)),O78),(((((O43,((O35,O77),(O39,O93))),((O83,O10"
        #     "),(O68,O87))),(((O61,O5),O55),O7)),(O86,O58)),((O4,((O24,((O9,O98),O52)),"
        #     "O60)),O3))),(O15,(O41,O33))),(((O22,O27),(O30,(O91,O72))),(((O82,O62),(O9"
        #     "7,((O21,O99),O65))),(O12,(O69,O17))))),((((((((O18,O50),(((((O47,O44),O53"
        #     "),O14),((O13,O31),(O8,O88))),O90)),O38),(O26,(O56,O45))),((((O71,O19),(O8"
        #     "5,(O11,O79))),((O6,O54),O29)),(O96,(O76,O46)))),(O32,(O95,O25))),((O80,(O"
        #     "34,O75)),((((O49,O40),(((O63,O36),O73),O48)),(O37,O51)),(((O16,((O94,O70)"
        #     ",O84)),O0),(O66,((O20,((O42,O92),O64)),(((O89,O2),O67),O28))))))),(O1,O81"
        #     ")));"
        # ])

    def test_validate_labels(self):
        # Create a simple matrix for testing
        matrix = np.array([[1, 2, 3], [4, 5, 6]])
        n = matrix.shape[0]

        # Test with valid 1D label
        label = np.array([0, 1])
        obs_label, obs_one_hot = _validate_labels(label, n)
        self.assertTrue(np.array_equal(obs_label, label))
        self.assertTrue(np.array_equal(obs_one_hot, np.array([[1, 0], [0, 1]])))

        # input as plain list
        obs_idx, obs_1hot = _validate_labels(label.tolist(), n)
        self.assertTrue(np.array_equal(obs_idx, label))
        self.assertTrue(np.array_equal(obs_1hot, np.array([[1, 0], [0, 1]])))

        # Test with valid 2D one-hot label
        one_hot = np.array([[1, 0], [0, 1]])
        obs_label, obs_one_hot = _validate_labels(one_hot, n)
        self.assertTrue(np.array_equal(obs_label, np.array([0, 1])))
        self.assertTrue(np.array_equal(obs_one_hot, one_hot))

        # Test with wrong number of samples
        wrong_label = np.array([0, 1, 2])
        with self.assertRaisesRegex(ValueError, "Number of elements in label"):
            _validate_labels(wrong_label, n)

        # Test with wrong dimensions
        wrong_dim_label = np.array([[[0], [1]]])
        with self.assertRaisesRegex(ValueError, "Label should have shape"):
            _validate_labels(wrong_dim_label, n)

        # Test with non-zero indexed label
        non_zero_label = np.array([1, 2])
        with self.assertRaisesRegex(ValueError, "Label must be zero-indexed"):
            _validate_labels(non_zero_label, n)

        # Test with non-consecutive label
        non_consecutive = np.array([0, 2])
        with self.assertRaisesRegex(ValueError, "Label must be consecutive integers"):
            _validate_labels(non_consecutive, n)

        # Test with invalid one-hot encoding
        invalid_one_hot = np.array([[1, 1], [0, 1]])
        with self.assertRaisesRegex(
            ValueError, "Labels are not properly one-hot encoded."
        ):
            _validate_labels(invalid_one_hot, n)

    def test_aitchison_operations(self):
        # Test Aitchison addition
        x = np.array([0.2, 0.3, 0.5])
        v = np.array([0.1, 0.4, 0.5])
        res = _aitchison_add(x, v)
        npt.assert_array_almost_equal(
            res, np.array([0.05128205, 0.30769231, 0.64102564])
        )
        self.assertAlmostEqual(np.sum(res), 1.0)

        # Test Aitchison scalar multiplication
        lam = 2.0
        x = np.array([0.2, 0.3, 0.5])
        res = _aitchison_scalar_multiply(lam, x)
        npt.assert_array_almost_equal(
            res, np.array([0.10526316, 0.23684211, 0.65789474])
        )
        self.assertAlmostEqual(np.sum(res), 1.0)

    def test_all_pairs(self):
        obs = _all_pairs(2)
        exp = np.array([[0, 1]])
        npt.assert_array_equal(obs, exp)

        obs = _all_pairs(3)
        exp = np.array([[0, 1], [0, 2], [1, 2]])
        npt.assert_array_equal(obs, exp)

        obs = _all_pairs(5)
        exp = np.array([[0, 0, 0, 0, 1, 1, 1, 2, 2, 3],
                        [1, 2, 3, 4, 2, 3, 4, 3, 4, 4]]).T
        npt.assert_array_equal(obs, exp)

        # edge case: one sample -> no pair
        obs = _all_pairs(1)
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

    def test_intra_class_pairs(self):
        # one class only
        obs = _intra_class_pairs([0, 0, 0])
        exp = np.array([[0, 1], [0, 2], [1, 2]])
        npt.assert_array_equal(obs, exp)

        # two classes, one pair each
        obs = _intra_class_pairs([0, 0, 1, 1])
        exp = np.array([[0, 1], [2, 3]])
        npt.assert_array_equal(obs, exp)

        # two classes, interleaved
        obs = _intra_class_pairs([0, 1, 0, 1])
        exp = np.array([[0, 2], [1, 3]])
        npt.assert_array_equal(obs, exp)

        # two classes, three pairs each
        obs = _intra_class_pairs([0, 0, 1, 1, 1, 0])
        exp = np.array([[0, 0, 1, 2, 2, 3],
                        [1, 5, 5, 3, 4, 4]]).T
        npt.assert_array_equal(obs, exp)

        # three classes, mixed pair numbers
        obs = _intra_class_pairs([0, 0, 1, 1, 2, 0, 2, 1, 1, 1])
        exp = np.array([[0, 0, 1, 2, 2, 2, 2, 3, 3, 3, 7, 7, 8, 4],
                        [1, 5, 5, 3, 7, 8, 9, 7, 8, 9, 8, 9, 9, 6]]).T
        npt.assert_array_equal(obs, exp)

        # edge case: no pair
        obs = _intra_class_pairs([0, 1, 2])
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

        # edge case: no sample
        obs = _intra_class_pairs([])
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

    def test_mixup(self):
        # no labels
        obs_mat, obs_lab = mixup(self.matrix, n=10, seed=42)
        exp_mat = np.array([
            [ 0.55,  0.  ,  2.27,  0.  ,  3.19,  9.95,  3.  ,  1.73,  0.82,  2.64],
            [ 0.  ,  2.36,  5.  ,  4.73,  1.79,  3.72,  2.43,  3.44,  7.22,  0.79],
            [ 0.  ,  4.64,  0.9 ,  0.82,  6.1 ,  0.36,  4.46,  1.64,  4.  ,  0.18],
            [ 0.  ,  0.  ,  1.69,  0.  ,  0.69,  1.69,  2.69,  1.69,  0.  ,  1.  ],
            [ 0.  ,  0.  ,  1.61,  0.  ,  0.61,  1.61,  2.61,  1.61,  0.  ,  1.  ],
            [ 0.  ,  1.91,  3.91,  0.  ,  1.64,  2.  ,  2.36,  0.73,  2.54,  1.  ],
            [ 1.31,  0.  ,  3.69,  7.55,  6.25, 23.79,  3.34,  6.15,  8.49,  4.6 ],
            [ 0.  ,  0.  ,  0.93,  5.72,  0.19,  4.3 ,  0.74,  5.42,  4.35,  0.  ],
            [ 2.08,  0.  ,  2.62,  0.93,  0.23,  6.33,  1.54,  0.77,  0.69,  2.16],
            [ 1.11,  0.  ,  2.55,  0.  ,  5.44, 18.08,  3.  ,  1.45,  1.66,  4.33],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        self.assertIsNone(obs_lab)

        # append mode
        obs_mat, obs_lab = mixup(self.matrix, n=10, seed=42, append=True)
        self.assertTupleEqual(obs_mat.shape, (20, 10))
        npt.assert_array_equal(obs_mat[:10], self.matrix)
        npt.assert_array_equal(obs_mat.round(2)[10:], exp_mat)

        # two-class labels
        obs_mat, obs_lab = mixup(self.matrix, n=10, labels=self.labels_2, seed=42)
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        exp_lab = np.array([
            [0.27, 0.73],
            [1.  , 0.  ],
            [0.18, 0.82],
            [0.31, 0.69],
            [0.39, 0.61],
            [0.64, 0.36],
            [1.  , 0.  ],
            [0.19, 0.81],
            [1.  , 0.  ],
            [0.55, 0.45],
        ])
        npt.assert_array_equal(obs_lab.round(2), exp_lab)

        # alpha parameter
        obs_mat, obs_lab = mixup(self.matrix, n=10, alpha=1, seed=42)
        exp_mat = np.array([
            [ 1.72,  0.  ,  2.86,  0.  ,  7.88, 26.94,  3.  ,  1.14,  2.58,  6.16],
            [ 0.  ,  1.35,  5.  , 12.07,  1.45,  6.39,  3.1 ,  8.78, 12.23,  0.45],
            [ 0.  ,  3.58,  3.55,  0.29,  3.45,  1.42,  2.87,  0.58,  4.  ,  0.71],
            [ 0.  ,  0.  ,  1.93,  0.  ,  0.93,  1.93,  2.93,  1.93,  0.  ,  1.  ],
            [ 0.  ,  0.  ,  1.71,  0.  ,  0.71,  1.71,  2.71,  1.71,  0.  ,  1.  ],
            [ 0.  ,  2.34,  4.34,  0.  ,  1.78,  2.  ,  2.22,  0.44,  3.12,  1.  ],
            [ 0.88,  0.  ,  4.12, 12.3 ,  4.53, 19.26,  3.56,  9.38, 11.94,  3.09],
            [ 0.  ,  0.  ,  2.97, 13.86,  0.59,  7.15,  2.37, 10.71, 11.68,  0.  ],
            [ 6.09,  0.  ,  5.74,  2.71,  0.68, 16.57,  0.65,  0.32,  2.03,  4.39],
            [ 0.59,  0.  ,  2.3 ,  0.  ,  3.38, 10.61,  3.  ,  1.7 ,  0.89,  2.78],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)

        # two-class labels, intra-class mixing
        obs_mat, obs_lab = mixup(
            self.matrix, n=10, labels=self.labels_2, intra_class=True, seed=42
        )
        exp_mat = np.array([
            [ 0.55,  0.  ,  1.55,  0.  ,  2.47,  9.22,  2.27,  1.  ,  0.82,  2.64],
            [ 0.  ,  1.07,  0.  ,  1.79,  1.5 ,  2.36,  1.07,  2.79,  1.64,  0.  ],
            [ 0.  ,  0.54,  5.  , 18.05,  1.18,  8.56,  3.64, 13.13, 16.31,  0.18],
            [ 0.  ,  0.  ,  3.77, 15.25,  0.69,  7.24,  3.39, 11.4 , 13.17,  0.31],
            [ 0.  ,  0.  ,  3.45, 13.48,  0.61,  6.51,  3.23, 10.19, 11.64,  0.39],
            [ 0.  ,  0.  ,  0.73,  1.27,  0.36,  2.64,  1.09,  2.64,  0.64,  0.36],
            [ 1.31,  0.  ,  2.31,  0.  ,  5.91, 20.7 ,  2.66,  1.  ,  1.97,  4.94],
            [ 2.79,  3.  ,  4.07,  1.49,  4.79,  1.63,  1.63,  0.93,  3.26,  0.81],
            [ 0.46,  2.31,  4.54,  0.  ,  3.62,  8.72,  2.23,  0.23,  3.77,  2.39],
            [ 1.11,  0.  ,  2.11,  0.  ,  4.99, 17.64,  2.55,  1.  ,  1.66,  4.33],
        ])
        exp_lab = np.array([
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [1, 0],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        npt.assert_array_equal(obs_lab, exp_lab)

        # three-class labels
        obs_mat, obs_lab = mixup(self.matrix, n=10, labels=self.labels_3, seed=42)
        exp_mat = np.array([
            [ 0.55,  0.  ,  2.27,  0.  ,  3.19,  9.95,  3.  ,  1.73,  0.82,  2.64],
            [ 0.  ,  2.36,  5.  ,  4.73,  1.79,  3.72,  2.43,  3.44,  7.22,  0.79],
            [ 0.  ,  4.64,  0.9 ,  0.82,  6.1 ,  0.36,  4.46,  1.64,  4.  ,  0.18],
            [ 0.  ,  0.  ,  1.69,  0.  ,  0.69,  1.69,  2.69,  1.69,  0.  ,  1.  ],
            [ 0.  ,  0.  ,  1.61,  0.  ,  0.61,  1.61,  2.61,  1.61,  0.  ,  1.  ],
            [ 0.  ,  1.91,  3.91,  0.  ,  1.64,  2.  ,  2.36,  0.73,  2.54,  1.  ],
            [ 1.31,  0.  ,  3.69,  7.55,  6.25, 23.79,  3.34,  6.15,  8.49,  4.6 ],
            [ 0.  ,  0.  ,  0.93,  5.72,  0.19,  4.3 ,  0.74,  5.42,  4.35,  0.  ],
            [ 2.08,  0.  ,  2.62,  0.93,  0.23,  6.33,  1.54,  0.77,  0.69,  2.16],
            [ 1.11,  0.  ,  2.55,  0.  ,  5.44, 18.08,  3.  ,  1.45,  1.66,  4.33],
        ])
        exp_lab = np.array([
            [0.73, 0.27, 0.  ],
            [0.21, 0.  , 0.79],
            [0.  , 0.  , 1.  ],
            [1.  , 0.  , 0.  ],
            [1.  , 0.  , 0.  ],
            [0.36, 0.  , 0.64],
            [0.34, 0.66, 0.  ],
            [1.  , 0.  , 0.  ],
            [0.77, 0.23, 0.  ],
            [0.45, 0.55, 0.  ],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        npt.assert_array_equal(obs_lab.round(2), exp_lab)

    def test_aitchison_mixup(self):
        # no labels
        obs_mat, obs_lab = aitchison_mixup(self.matrix, n=10, seed=42)
        exp_mat = np.array([
            [0.  , 0.  , 0.15, 0.  , 0.12, 0.29, 0.2 , 0.11, 0.  , 0.12],
            [0.  , 0.  , 0.29, 0.  , 0.1 , 0.16, 0.13, 0.  , 0.32, 0.  ],
            [0.  , 0.25, 0.  , 0.  , 0.3 , 0.  , 0.23, 0.  , 0.22, 0.  ],
            [0.  , 0.  , 0.19, 0.  , 0.  , 0.19, 0.31, 0.19, 0.  , 0.12],
            [0.  , 0.  , 0.19, 0.  , 0.  , 0.19, 0.31, 0.19, 0.  , 0.12],
            [0.  , 0.  , 0.34, 0.  , 0.15, 0.19, 0.22, 0.  , 0.  , 0.1 ],
            [0.  , 0.  , 0.09, 0.  , 0.1 , 0.52, 0.08, 0.06, 0.14, 0.  ],
            [0.  , 0.  , 0.  , 0.25, 0.  , 0.3 , 0.  , 0.32, 0.14, 0.  ],
            [0.  , 0.  , 0.31, 0.  , 0.  , 0.4 , 0.  , 0.  , 0.  , 0.29],
            [0.  , 0.  , 0.11, 0.  , 0.15, 0.41, 0.13, 0.06, 0.  , 0.13],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        self.assertIsNone(obs_lab)

        # check if the synthetic samples are also compositional
        self.assertTrue(np.allclose(obs_mat.sum(axis=1), 1))

        # append mode
        obs_mat, obs_lab = aitchison_mixup(self.matrix, n=10, seed=42, append=True)
        self.assertTupleEqual(obs_mat.shape, (20, 10))
        npt.assert_array_equal(obs_mat.round(2)[10:], exp_mat)

        # check if the original samples have been normalized
        npt.assert_array_equal(obs_mat[:10].round(2), closure(self.matrix).round(2))

        # two-class labels
        obs_mat, obs_lab = aitchison_mixup(
            self.matrix, n=10, labels=self.labels_2, seed=42
        )
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        # Note that the synthetic labels are identical to those of `mixup`. This is
        # because they are determined by sampling from beta distribution, which is
        # independent from the subsequent calculation.
        exp_lab = np.array([
            [0.27, 0.73],
            [1.  , 0.  ],
            [0.18, 0.82],
            [0.31, 0.69],
            [0.39, 0.61],
            [0.64, 0.36],
            [1.  , 0.  ],
            [0.19, 0.81],
            [1.  , 0.  ],
            [0.55, 0.45],
        ])
        npt.assert_array_equal(obs_lab.round(2), exp_lab)

        # alpha parameter
        obs_mat, obs_lab = aitchison_mixup(self.matrix, n=10, alpha=1, seed=42)
        exp_mat = np.array([
            [0.  , 0.  , 0.07, 0.  , 0.17, 0.53, 0.08, 0.03, 0.  , 0.13],
            [0.  , 0.  , 0.21, 0.  , 0.06, 0.21, 0.12, 0.  , 0.4 , 0.  ],
            [0.  , 0.27, 0.  , 0.  , 0.22, 0.  , 0.2 , 0.  , 0.31, 0.  ],
            [0.  , 0.  , 0.2 , 0.  , 0.  , 0.2 , 0.3 , 0.2 , 0.  , 0.1 ],
            [0.  , 0.  , 0.19, 0.  , 0.  , 0.19, 0.31, 0.19, 0.  , 0.12],
            [0.  , 0.  , 0.37, 0.  , 0.16, 0.18, 0.2 , 0.  , 0.  , 0.09],
            [0.  , 0.  , 0.1 , 0.  , 0.07, 0.41, 0.09, 0.12, 0.21, 0.  ],
            [0.  , 0.  , 0.  , 0.29, 0.  , 0.22, 0.  , 0.29, 0.2 , 0.  ],
            [0.  , 0.  , 0.25, 0.  , 0.  , 0.54, 0.  , 0.  , 0.  , 0.21],
            [0.  , 0.  , 0.15, 0.  , 0.13, 0.3 , 0.2 , 0.11, 0.  , 0.12],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        self.assertTrue(np.allclose(obs_mat.sum(axis=1), 1))

        # two-class labels, intra-class mixing
        obs_mat, obs_lab = aitchison_mixup(
            self.matrix, n=10, labels=self.labels_2, intra_class=True, seed=42
        )
        exp_mat = np.array([
            [0.  , 0.  , 0.15, 0.  , 0.  , 0.29, 0.25, 0.11, 0.  , 0.19],
            [0.  , 0.  , 0.  , 0.3 , 0.  , 0.  , 0.  , 0.47, 0.23, 0.  ],
            [0.  , 0.  , 0.16, 0.  , 0.04, 0.24, 0.11, 0.  , 0.46, 0.  ],
            [0.  , 0.  , 0.17, 0.  , 0.  , 0.27, 0.18, 0.38, 0.  , 0.  ],
            [0.  , 0.  , 0.18, 0.  , 0.  , 0.27, 0.2 , 0.36, 0.  , 0.  ],
            [0.  , 0.  , 0.  , 0.  , 0.  , 0.5 , 0.  , 0.5 , 0.  , 0.  ],
            [0.  , 0.  , 0.11, 0.  , 0.  , 0.51, 0.14, 0.05, 0.  , 0.19],
            [0.  , 0.5 , 0.  , 0.  , 0.5 , 0.  , 0.  , 0.  , 0.  , 0.  ],
            [0.  , 0.  , 0.24, 0.  , 0.15, 0.2 , 0.12, 0.  , 0.2 , 0.08],
            [0.  , 0.  , 0.12, 0.  , 0.  , 0.45, 0.17, 0.07, 0.  , 0.2 ],
        ])
        exp_lab = np.array([
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [1, 0],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        npt.assert_array_equal(obs_lab, exp_lab)
        self.assertTrue(np.allclose(obs_mat.sum(axis=1), 1))

        # three-class labels
        obs_mat, obs_lab = aitchison_mixup(
            self.matrix, n=10, labels=self.labels_3, seed=42
        )
        exp_mat = np.array([
            [0.  , 0.  , 0.15, 0.  , 0.12, 0.29, 0.2 , 0.11, 0.  , 0.12],
            [0.  , 0.  , 0.29, 0.  , 0.1 , 0.16, 0.13, 0.  , 0.32, 0.  ],
            [0.  , 0.25, 0.  , 0.  , 0.3 , 0.  , 0.23, 0.  , 0.22, 0.  ],
            [0.  , 0.  , 0.19, 0.  , 0.  , 0.19, 0.31, 0.19, 0.  , 0.12],
            [0.  , 0.  , 0.19, 0.  , 0.  , 0.19, 0.31, 0.19, 0.  , 0.12],
            [0.  , 0.  , 0.34, 0.  , 0.15, 0.19, 0.22, 0.  , 0.  , 0.1 ],
            [0.  , 0.  , 0.09, 0.  , 0.1 , 0.52, 0.08, 0.06, 0.14, 0.  ],
            [0.  , 0.  , 0.  , 0.25, 0.  , 0.3 , 0.  , 0.32, 0.14, 0.  ],
            [0.  , 0.  , 0.31, 0.  , 0.  , 0.4 , 0.  , 0.  , 0.  , 0.29],
            [0.  , 0.  , 0.11, 0.  , 0.15, 0.41, 0.13, 0.06, 0.  , 0.13],
        ])
        exp_lab = np.array([
            [0.73, 0.27, 0.  ],
            [0.21, 0.  , 0.79],
            [0.  , 0.  , 1.  ],
            [1.  , 0.  , 0.  ],
            [1.  , 0.  , 0.  ],
            [0.36, 0.  , 0.64],
            [0.34, 0.66, 0.  ],
            [1.  , 0.  , 0.  ],
            [0.77, 0.23, 0.  ],
            [0.45, 0.55, 0.  ],
        ])
        npt.assert_array_equal(obs_mat.round(2), exp_mat)
        npt.assert_array_equal(obs_lab.round(2), exp_lab)
        self.assertTrue(np.allclose(obs_mat.sum(axis=1), 1))

    # def test_compositional_cutmix(self):
    #     exp_mat, exp_lab = compositional_cutmix(
    #         self.data, n=20, labels=self.label, seed=42
    #     )

    #     self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
    #     self.assertEqual(exp_mat.shape[1], self.data.shape[1])
    #     # Check if the augmented data is compositional
    #     # this rtol is really low, the data seems to be close to compositionality, but
    #     # not quite, it is within 0.9 - 1.1
    #     self.assertTrue(np.allclose(np.sum(exp_mat, axis=1), 1.0, rtol=1e-01))
    #     self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
    #     # compositional_cutmix returns a 2D output for label
    #     self.assertEqual(exp_lab.shape[1], 2)

    # def test_phylomix_simple(self):
    #     exp_mat, exp_lab = phylomix(
    #         self.data_simple,
    #         n=20,
    #         tree=self.tree_simple,
    #         taxa=self.taxa_simple,
    #         label=self.label_simple,
    #     )
    #     # TODO: test label?
    #     self.assertEqual(exp_mat.shape[0], self.data_simple.shape[0] + 20)
    #     self.assertEqual(exp_mat.shape[1], self.data_simple.shape[1])

    # def test_phylomix_bad_tips(self):
    #     bad_mapping = {
    #         k: v for k, v in self.tips_to_feature_mapping_simple.items() if k != "a"
    #     }
    #     with self.assertRaisesRegex(
    #         ValueError, "tip_to_obs_mapping must contain all tips in the tree"
    #     ):
    #         phylomix(
    #             self.data_simple,
    #             tree=self.tree_simple,
    #             samples=20,
    #             taxa=list("abcde"),
    #             label=self.label_simple,
    #         )

    def test_phylomix(self):
        matrix, tree, taxa, = self.matrix, self.tree, self.taxa

        # no labels
        obs_mat, obs_lab = phylomix(matrix, n=10, tree=tree, taxa=taxa, seed=42)
        exp_mat = np.array([
            [ 0,  0,  0,  0,  1,  4,  3,  0,  0,  1],
            [ 0, 12, 21,  0,  8,  8,  8,  0, 17,  0],
            [ 0,  3,  5,  0,  2,  2,  2,  0,  4,  1],
            [ 0,  0,  2,  0,  0,  2,  3,  2,  0,  1],
            [ 0,  0,  2,  0,  0,  2,  3,  2,  0,  2],
            [ 0,  1,  2,  0,  1,  1,  1,  2,  2,  0],
            [ 2,  0,  3,  0,  9,  7,  3, 12, 14,  7],
            [ 0,  0,  0, 17,  0, 25,  0, 25,  8,  0],
            [ 0,  0, 13,  0,  0, 13,  0, 13,  0, 13],
            [ 0,  0,  0,  0,  1,  3,  3,  2,  0,  0],
        ])
        npt.assert_array_equal(obs_mat, exp_mat)
        self.assertIsNone(obs_lab)

        # append mode
        obs_mat, obs_lab = phylomix(
            matrix, n=10, tree=tree, taxa=taxa, seed=42, append=True
        )
        self.assertTupleEqual(obs_mat.shape, (20, 10))
        npt.assert_array_equal(obs_mat[:10], self.matrix)
        npt.assert_array_equal(obs_mat[10:], exp_mat)

        # two-class labels
        obs_mat, obs_lab = phylomix(
            matrix, n=10, tree=tree, taxa=taxa, labels=self.labels_2, seed=42
        )
        npt.assert_array_equal(obs_mat, exp_mat)
        # Note that the synthetic labels won't be the same as those of `mixup`. This is
        # because `phylomix` shuffles pairs of sample indices to ensure randomness.
        exp_lab = np.array([
            [0.73, 0.27],
            [1.  , 0.  ],
            [0.82, 0.18],
            [0.69, 0.31],
            [0.61, 0.39],
            [0.64, 0.36],
            [1.  , 0.  ],
            [0.19, 0.81],
            [1.  , 0.  ],
            [0.45, 0.55],
        ])
        npt.assert_array_equal(obs_lab.round(2), exp_lab)

        # alpha parameter
        obs_mat, obs_lab = phylomix(
            matrix, n=10, tree=tree, taxa=taxa, alpha=1, seed=42
        )
        exp_mat = np.array([
            [ 0,  0,  2,  0,  1,  2,  3,  2,  0,  1],
            [ 0,  0,  1,  5,  2,  2,  2,  0,  4,  1],
            [ 0,  4,  0,  0,  5,  0,  2,  1,  3,  1],
            [ 0,  0,  1,  0,  0,  1,  1,  1,  0,  0],
            [ 0,  0,  1,  0,  0,  1,  1,  1,  0,  0],
            [ 0,  2,  2,  0,  1,  1,  1,  0,  2,  0],
            [ 2,  0,  4, 17,  0,  8,  3,  1, 15,  7],
            [ 0,  0,  0,  1,  0,  3,  0,  3,  1,  0],
            [ 9,  0, 16,  0,  0, 24,  0,  0,  0,  6],
            [ 0,  0,  2,  0,  1,  5,  0,  0,  0,  1],
        ])
        npt.assert_array_equal(obs_mat, exp_mat)

        # two-class labels, intra-class mixing
        obs_mat, obs_lab = phylomix(
            self.matrix, n=10, tree=tree, taxa=taxa, labels=self.labels_2,
            intra_class=True, seed=42
        )
        exp_mat = np.array([
            [ 0,  0,  0,  0,  0,  2,  2,  0,  0,  0],
            [ 0,  0,  0,  5,  0,  8,  0,  8,  2,  0],
            [ 0,  3,  5,  0,  2,  2,  2,  0,  4,  1],
            [ 0,  0, 24,  0,  0, 24,  4, 24,  0,  0],
            [ 0,  0,  5,  0,  0, 22,  4, 22,  0, 22],
            [ 0,  0,  2,  2,  0,  3,  0,  2,  1,  0],
            [ 2,  0,  3,  0,  9, 17,  3, 17,  0,  7],
            [ 0,  8, 13,  0,  5,  5,  5,  0, 10,  0],
            [ 0,  0, 20,  0,  8,  8,  3,  0, 16,  4],
            [ 0,  0,  0,  0,  0,  2,  2,  1,  0,  0],
        ])
        exp_lab = np.array([
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [0, 1],
            [1, 0],
            [1, 0],
            [1, 0],
            [1, 0],
        ])
        npt.assert_array_equal(obs_mat, exp_mat)
        npt.assert_array_equal(obs_lab, exp_lab)

        # three-class labels
        obs_mat, obs_lab = phylomix(
            self.matrix, n=10, tree=tree, taxa=taxa, labels=self.labels_3, seed=42
        )
        exp_mat = np.array([
            [ 0,  0,  0,  0,  1,  4,  3,  0,  0,  1],
            [ 0, 12, 21,  0,  8,  8,  8,  0, 17,  0],
            [ 0,  3,  5,  0,  2,  2,  2,  0,  4,  1],
            [ 0,  0,  2,  0,  0,  2,  3,  2,  0,  1],
            [ 0,  0,  2,  0,  0,  2,  3,  2,  0,  2],
            [ 0,  1,  2,  0,  1,  1,  1,  2,  2,  0],
            [ 2,  0,  3,  0,  9,  7,  3, 12, 14,  7],
            [ 0,  0,  0, 17,  0, 25,  0, 25,  8,  0],
            [ 0,  0, 13,  0,  0, 13,  0, 13,  0, 13],
            [ 0,  0,  0,  0,  1,  3,  3,  2,  0,  0],
        ])
        exp_lab = np.array([
            [0.27, 0.73, 0.  ],
            [0.21, 0.  , 0.79],
            [0.  , 0.  , 1.  ],
            [1.  , 0.  , 0.  ],
            [1.  , 0.  , 0.  ],
            [0.36, 0.  , 0.64],
            [0.34, 0.66, 0.  ],
            [1.  , 0.  , 0.  ],
            [0.77, 0.23, 0.  ],
            [0.55, 0.45, 0.  ],
        ])
        npt.assert_array_equal(obs_mat, exp_mat)
        npt.assert_array_equal(obs_lab.round(2), exp_lab)

        # exp_mat, exp_lab = phylomix(
        #     self.data,
        #     n=20,
        #     tree=self.tree,
        #     taxa=self.taxa,
        #     labels=self.label,
        # )

        # self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
        # self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        # self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
        # self.assertEqual(exp_lab.shape[1], 2)
        # self.assertTrue(np.allclose(np.sum(exp_lab, axis=1), 1.0))


if __name__ == "__main__":
    main()
