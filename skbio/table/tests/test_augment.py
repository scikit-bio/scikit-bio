# ----------------------------------------------------------------------------
# Copyright (c) 2013--, scikit-bio development team.
#
# Distributed under the terms of the Modified BSD License.
#
# The full license is in the file LICENSE.txt, distributed with this software.
# ----------------------------------------------------------------------------

from unittest import TestCase, main

import numpy as np
import numpy.testing as npt

from skbio.tree import TreeNode
from skbio.table._augment import (
    mixup,
    aitchison_mixup,
    compositional_cutmix,
    phylomix,
    _validate_label,
    _all_pairs,
    _intra_class_pairs,
    _aitchison_add,
    _aitchison_scalar_multiply,
)


class AugmentationTests(TestCase):

    def setUp(self):
        # a simple example (2 x 5)
        self.data_simple = np.arange(10).reshape(2, 5)
        self.label_simple = np.array([0, 1])
        self.taxa_simple = list("abcde")
        self.tree_simple = TreeNode.read(["(((a,b),c),(d,e));"])

        # a complex example (40 x 100)
        self.data = np.arange(4000).reshape(40, 100)
        rng = np.random.default_rng()
        self.label = rng.integers(0, 2, size=40)
        self.one_hot_label = np.eye(2)[self.label]
        self.taxa = [f"O{i}" for i in range(100)]

        # This is a random birth-death tree generated by DendroPy. Code:
        # taxa = dendropy.TaxonNamespace([f"O{i}" for i in range(100)])
        # tree = dendropy.simulate.treesim.birth_death_tree(
        #     birth_rate=1.0, death_rate=0.0, num_extant_tips=100,
        #     taxon_namespace=taxa, rng=random.Random(42))
        self.tree = TreeNode.read([
            "(((((((O59,O57),(O23,O74)),O78),(((((O43,((O35,O77),(O39,O93))),((O83,O10"
            "),(O68,O87))),(((O61,O5),O55),O7)),(O86,O58)),((O4,((O24,((O9,O98),O52)),"
            "O60)),O3))),(O15,(O41,O33))),(((O22,O27),(O30,(O91,O72))),(((O82,O62),(O9"
            "7,((O21,O99),O65))),(O12,(O69,O17))))),((((((((O18,O50),(((((O47,O44),O53"
            "),O14),((O13,O31),(O8,O88))),O90)),O38),(O26,(O56,O45))),((((O71,O19),(O8"
            "5,(O11,O79))),((O6,O54),O29)),(O96,(O76,O46)))),(O32,(O95,O25))),((O80,(O"
            "34,O75)),((((O49,O40),(((O63,O36),O73),O48)),(O37,O51)),(((O16,((O94,O70)"
            ",O84)),O0),(O66,((O20,((O42,O92),O64)),(((O89,O2),O67),O28))))))),(O1,O81"
            ")));"
        ])

    def test_validate_label(self):
        # Create a simple matrix for testing
        matrix = np.array([[1, 2, 3], [4, 5, 6]])

        # Test with valid 1D label
        label = np.array([0, 1])
        obs_label, obs_one_hot = _validate_label(label, matrix)
        self.assertTrue(np.array_equal(obs_label, label))
        self.assertTrue(np.array_equal(obs_one_hot, np.array([[1, 0], [0, 1]])))

        # Test with valid 2D one-hot label
        one_hot = np.array([[1, 0], [0, 1]])
        obs_label, obs_one_hot = _validate_label(one_hot, matrix)
        self.assertTrue(np.array_equal(obs_label, np.array([0, 1])))
        self.assertTrue(np.array_equal(obs_one_hot, one_hot))

        # Test with wrong number of samples
        wrong_label = np.array([0, 1, 2])
        with self.assertRaisesRegex(ValueError, "Number of elements in label"):
            _validate_label(wrong_label, matrix)

        # Test with non-numpy array
        with self.assertRaisesRegex(ValueError, "Label must be a numpy.ndarray"):
            _validate_label([0, 1], matrix)

        # Test with wrong dimensions
        wrong_dim_label = np.array([[[0], [1]]])
        with self.assertRaisesRegex(ValueError, "Label should have shape"):
            _validate_label(wrong_dim_label, matrix)

        # Test with non-zero indexed label
        non_zero_label = np.array([1, 2])
        with self.assertRaisesRegex(ValueError, "Label must be zero-indexed"):
            _validate_label(non_zero_label, matrix)

        # Test with non-consecutive label
        non_consecutive = np.array([0, 2])
        with self.assertRaisesRegex(ValueError, "Label must be consecutive integers"):
            _validate_label(non_consecutive, matrix)

        # Test with invalid one-hot encoding
        invalid_one_hot = np.array([[1, 1], [0, 1]])
        with self.assertRaisesRegex(
            ValueError, "Label is not properly one-hot encoded"
        ):
            _validate_label(invalid_one_hot, matrix)

    def test_aitchison_operations(self):
        # Test Aitchison addition
        x = np.array([0.2, 0.3, 0.5])
        v = np.array([0.1, 0.4, 0.5])
        res = _aitchison_add(x, v)
        npt.assert_array_almost_equal(
            res, np.array([0.05128205, 0.30769231, 0.64102564])
        )
        self.assertAlmostEqual(np.sum(res), 1.0)

        # Test Aitchison scalar multiplication
        lam = 2.0
        x = np.array([0.2, 0.3, 0.5])
        res = _aitchison_scalar_multiply(lam, x)
        npt.assert_array_almost_equal(
            res, np.array([0.10526316, 0.23684211, 0.65789474])
        )
        self.assertAlmostEqual(np.sum(res), 1.0)

    def test_all_pairs(self):
        obs = _all_pairs(2)
        exp = np.array([[0, 1]])
        npt.assert_array_equal(obs, exp)

        obs = _all_pairs(3)
        exp = np.array([[0, 1], [0, 2], [1, 2]])
        npt.assert_array_equal(obs, exp)

        obs = _all_pairs(5)
        exp = np.array([[0, 0, 0, 0, 1, 1, 1, 2, 2, 3],
                        [1, 2, 3, 4, 2, 3, 4, 3, 4, 4]]).T
        npt.assert_array_equal(obs, exp)

        # edge case: one sample -> no pair
        obs = _all_pairs(1)
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

    def test_intra_class_pairs(self):
        # one class only
        obs = _intra_class_pairs([0, 0, 0])
        exp = np.array([[0, 1], [0, 2], [1, 2]])
        npt.assert_array_equal(obs, exp)

        # two classes, one pair each
        obs = _intra_class_pairs([0, 0, 1, 1])
        exp = np.array([[0, 1], [2, 3]])
        npt.assert_array_equal(obs, exp)

        # two classes, interleaved
        obs = _intra_class_pairs([0, 1, 0, 1])
        exp = np.array([[0, 2], [1, 3]])
        npt.assert_array_equal(obs, exp)

        # two classes, three pairs each
        obs = _intra_class_pairs([0, 0, 1, 1, 1, 0])
        exp = np.array([[0, 0, 1, 2, 2, 3],
                        [1, 5, 5, 3, 4, 4]]).T
        npt.assert_array_equal(obs, exp)

        # three classes, mixed pair numbers
        obs = _intra_class_pairs([0, 0, 1, 1, 2, 0, 2, 1, 1, 1])
        exp = np.array([[0, 0, 1, 2, 2, 2, 2, 3, 3, 3, 7, 7, 8, 4],
                        [1, 5, 5, 3, 7, 8, 9, 7, 8, 9, 8, 9, 9, 6]]).T
        npt.assert_array_equal(obs, exp)

        # edge case: no pair
        obs = _intra_class_pairs([0, 1, 2])
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

        # edge case: no sample
        obs = _intra_class_pairs([])
        exp = np.empty((0, 2), dtype=int)
        npt.assert_array_equal(obs, exp)

    def test_mixup(self):
        exp_mat, exp_lab = mixup(self.data, n=10, label=self.label, alpha=2)
        self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 10)
        self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        self.assertEqual(exp_lab.shape[0], len(self.label) + 10)
        self.assertEqual(exp_lab.shape[1], 2)
        self.assertTrue(np.allclose(np.sum(exp_lab, axis=1), 1.0))

    def test_mixup_no_label(self):
        _, exp_lab = mixup(self.data, n=10, alpha=2)
        self.assertTrue(exp_lab.empty)

    def test_aitchison_mixup(self):
        exp_mat, exp_lab = aitchison_mixup(
            self.data, n=20, label=self.label, alpha=2
        )

        self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
        self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        # Check if the augmented data is compositional
        self.assertTrue(np.allclose(np.sum(exp_mat, axis=1), 1.0))
        self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
        self.assertEqual(exp_lab.shape[1], 2)
        self.assertTrue(np.allclose(np.sum(exp_lab, axis=1), 1.0))

    # the previous test should be enough, but I'm not clear whether users should
    # even be allowed to turn off normalization for this function?
    # def test_aitchison_mixup_non_compositional(self):
    #     # Test with non-compositional data (should normalize)
    #     exp_mat, exp_lab = aitchison_mixup(
    #         self.table, samples=20, label=self.label, alpha=2
    #     )

    #     self.assertEqual(exp_mat.shape[0], self.table.shape[1] + 20)
    #     self.assertEqual(exp_mat.shape[1], self.table.shape[0])
    #     # Check if the augmented data is compositional
    #     self.assertTrue(np.allclose(np.sum(exp_mat, axis=1), 1.0))
    #     self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
    #     self.assertEqual(exp_lab.shape[1], 2)
    #     self.assertTrue(np.allclose(np.sum(exp_lab, axis=1), 1.0))

    def test_aitchison_mixup_no_label(self):
        _, exp_lab = aitchison_mixup(self.data, n=20, alpha=2)
        self.assertTrue(exp_lab.empty)

    def test_compositional_cutmix(self):
        exp_mat, exp_lab = compositional_cutmix(
            self.data, n=20, label=self.label, seed=42
        )

        self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
        self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        # Check if the augmented data is compositional
        # this rtol is really low, the data seems to be close to compositionality, but
        # not quite, it is within 0.9 - 1.1
        self.assertTrue(np.allclose(np.sum(exp_mat, axis=1), 1.0, rtol=1e-01))
        self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
        # compositional_cutmix returns a 2D output for label
        self.assertEqual(exp_lab.shape[1], 2)

    # def test_phylomix_simple(self):
    #     exp_mat, exp_lab = phylomix(
    #         self.data_simple,
    #         n=20,
    #         tree=self.tree_simple,
    #         taxa=self.taxa_simple,
    #         label=self.label_simple,
    #     )
    #     # TODO: test label?
    #     self.assertEqual(exp_mat.shape[0], self.data_simple.shape[0] + 20)
    #     self.assertEqual(exp_mat.shape[1], self.data_simple.shape[1])

    # def test_phylomix_bad_tips(self):
    #     bad_mapping = {
    #         k: v for k, v in self.tips_to_feature_mapping_simple.items() if k != "a"
    #     }
    #     with self.assertRaisesRegex(
    #         ValueError, "tip_to_obs_mapping must contain all tips in the tree"
    #     ):
    #         phylomix(
    #             self.data_simple,
    #             tree=self.tree_simple,
    #             samples=20,
    #             taxa=list("abcde"),
    #             label=self.label_simple,
    #         )

    def test_phylomix_no_label(self):
        exp_mat, exp_lab = phylomix(
            self.data_simple,
            n=20,
            tree=self.tree_simple,
            taxa=self.taxa_simple,
        )

        self.assertEqual(exp_mat.shape[0], self.data_simple.shape[0] + 20)
        self.assertEqual(exp_mat.shape[1], self.data_simple.shape[1])
        self.assertTrue(exp_lab.empty)

    def test_phylomix(self):
        exp_mat, exp_lab = phylomix(
            self.data,
            n=20,
            tree=self.tree,
            taxa=self.taxa,
            label=self.label,
        )

        self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
        self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        self.assertEqual(exp_lab.shape[0], len(self.label) + 20)
        self.assertEqual(exp_lab.shape[1], 2)
        self.assertTrue(np.allclose(np.sum(exp_lab, axis=1), 1.0))

    def test_phylomix_multiclass(self):
        label_multiclass = np.random.randint(0, 3, size=self.data.shape[0])
        exp_mat, exp_lab = phylomix(
            self.data,
            n=20,
            tree=self.tree,
            taxa=self.taxa,
            label=label_multiclass,
        )

        self.assertEqual(exp_mat.shape[0], self.data.shape[0] + 20)
        self.assertEqual(exp_mat.shape[1], self.data.shape[1])
        self.assertEqual(exp_lab.shape[0], len(label_multiclass) + 20)
        self.assertEqual(exp_lab.shape[1], 3)  # 3 classes


if __name__ == "__main__":
    main()
